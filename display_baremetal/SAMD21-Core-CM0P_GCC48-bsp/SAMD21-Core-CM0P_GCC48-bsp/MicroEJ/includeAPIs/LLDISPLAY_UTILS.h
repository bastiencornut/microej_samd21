/* 
 * Icetea
 * 
 * Copyright 2015-2016 IS2T. All rights reserved.
 * IS2T PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
/* 
 * AUTOGENERATED by COMP-ICETEA-CGNU-ARM - 1.0.0 - DO NOT EDIT IT
 */
/**
 * Provides some API to use the display stack from the adaptation layer. <br>
 * <br>
 * Several functions require a <code>graphicsContextID</code>. This ID can be retrieved
 * from the MicroUI application using the following APIs:
 * <ul>
 * <li>graphicsContext.hashCode();	// where <code>graphicsContext</code> is a <code>GraphicsContext</code> instance</li>
 * <li>image.hashCode();	// where <code>image</code> is an <code>Image</code> instance</li>
 * </ul>
 */
#ifndef _LLDISPLAY_UTILS
#define _LLDISPLAY_UTILS 
#include <intern/LLDISPLAY_UTILS.h>
#include <stdint.h>
#ifdef __cplusplus
	extern "C" {
#endif
// --------------------------------------------------------------------------------
// -                                  Constants                                   -
// --------------------------------------------------------------------------------

/**
 * Returned value when function call has succeeded.
 */
#define LLDISPLAY_UTILS_OK (0)

/**
 * Returned value when given dirty area is out of clip.
 * @see LLDISPLAY_UTILS_setDrawingLimits
 */
#define LLDISPLAY_UTILS_OUT_OF_CLIP (-9)

/**
 * Returned value when there is not enough memory.
 * @see LLDISPLAY_UTILS_allocateDecoderImage
 */
#define LLDISPLAY_UTILS_OUT_OF_MEMORY (-2)

// --------------------------------------------------------------------------------
// -                      Functions provided by the platform                      -
// --------------------------------------------------------------------------------

/**
 * Returns the buffer address of the MicroUI graphics context specified by
 * the given ID. This buffer can be located in runtime memory (RAM, SRAM, SDRAM etc.)
 * or in read-only memory (internal flash, NOR etc.).
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment. 
 * @return the MicroUI <code>GraphicsContext</code> buffer address
 */
int32_t LLDISPLAY_UTILS_getBufferAddress(int32_t graphicsContextID);

/**
 * Returns the width of the MicroUI graphics context specified by
 * the given ID.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @return the MicroUI <code>GraphicsContext</code> width
 */
int32_t LLDISPLAY_UTILS_getWidth(int32_t graphicsContextID);

/**
 * Returns the height of the MicroUI graphics context specified by
 * the given ID.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @return the MicroUI <code>GraphicsContext</code> height
 */
int32_t LLDISPLAY_UTILS_getHeight(int32_t graphicsContextID);

/**
 * Returns the format of the MicroUI graphics context specified by
 * the given ID.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @return the MicroUI <code>GraphicsContext</code> format
 */
int32_t LLDISPLAY_UTILS_getFormat(int32_t graphicsContextID);

/**
 * Enters in a critical section of the display stack.<br>
 * <br>
 * Call this function in order to synchronize adaptation layer drawings with 
 * the MicroUI application drawings. This ensures to synchronize the display stack's
 * pending drawings with the future C custom drawings. 
 */
void LLDISPLAY_UTILS_enterDrawingMode(void);

/**
 * Exits from a critical section of the display stack.
 * @see LLDISPLAY_UTILS_enterDrawingMode
 */
void LLDISPLAY_UTILS_exitDrawingMode(void);

/**
 * Updates the dirty area. Useful when the destination buffer is the LCD back
 * buffer. This dirty area will be merged with the current dirty area and given
 * as parameter in flush function.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @param xmin the dirty area top-left X coordinate
 * @param ymin the dirty area top-left Y coordinate
 * @param xmax the dirty area bottom-right X coordinate
 * @param ymax the dirty area bottom-right Y coordinate
 * @return {@link LLDISPLAY_UTILS_OK} when dirty area has been updated or {@link LLDISPLAY_UTILS_OUT_OF_CLIP} when
 * the specified dirty area is out of current clip.
 */
int32_t LLDISPLAY_UTILS_setDrawingLimits(int32_t graphicsContextID, int32_t xmin, int32_t ymin, int32_t xmax, int32_t ymax);

/**
 * Updates the current clip. Beware: this call corrupts the clip used by the 
 * MicroUI application. To prevent that, store current clip before changing 
 * it and restore it before leaving.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @param x1 the clip top-left X coordinate
 * @param y1 the clip top-left Y coordinate
 * @param x2 the clip bottom-right X coordinate
 * @param y2 the clip bottom-right Y coordinate
 */
void LLDISPLAY_UTILS_setClip(int32_t graphicsContextID, int32_t x1, int32_t y1, int32_t x2, int32_t y2);

/**
 * Returns the current clip top-left X coordinate.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @return the current clip top-left X coordinate.
 */
int32_t LLDISPLAY_UTILS_getClipX1(int32_t graphicsContextID);

/**
 * Returns the current clip top-left Y coordinate.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @return the current clip top-left Y coordinate.
 */
int32_t LLDISPLAY_UTILS_getClipY1(int32_t graphicsContextID);

/**
 * Returns the current clip bottom-right X coordinate.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @return the current clip bottom-right X coordinate.
 */
int32_t LLDISPLAY_UTILS_getClipX2(int32_t graphicsContextID);

/**
 * Returns the current clip bottom-right Y coordinate.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @return the current clip bottom-right Y coordinate.
 */
int32_t LLDISPLAY_UTILS_getClipY2(int32_t graphicsContextID);

/**
 * Blends two colors applying a global alpha factor.
 * @param foreground the ARGB8888 foreground color
 * @param background the ARGB8888 background color
 * @param alpha the global alpha factor
 * @return an ARGB8888 color
 */
int32_t LLDISPLAY_UTILS_blend(int32_t foreground, int32_t background, int32_t alpha);

/**
 * Draws a pixel on display or on a mutable image.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @param x the pixel X coordinate
 * @param y the pixel Y coordinate
 * @param color the pixel ARGB8888 color
 */
void LLDISPLAY_UTILS_drawPixel(int32_t graphicsContextID, int32_t x, int32_t y, int32_t color);

/**
 * Reads a pixel from a graphics context.
 * @param graphicsContextID the <code>GraphicsContext</code> ID, see header comment.
 * @param x the pixel X coordinate
 * @param y the pixel Y coordinate
 * @return the pixel ARGB8888 color
 */
int32_t LLDISPLAY_UTILS_readPixel(int32_t graphicsContextID, int32_t x, int32_t y);

/**
 * Allocates a memory area in working buffer where store the decoder RAW image 
 * pixels. The parameter <code>data</code> must be filled with the RAW image 
 * characteristics: its width, height, minimal row stride and the RAW image format.
 * This function will adjust the row stride value if required, will allocate the
 * pixels buffer and will update the structure <code>data<code>.<br>
 * <br>
 * This function must be called by the implementation of <code>LLDISPLAY_EXTRA_decodeImage</code>.
 * @param data the image characteristics (LLDISPLAY_SDecoderImageData*)
 * @return {@link LLDISPLAY_UTILS_OK} or a negative error value to return to MicroEJ framework 
 */
int32_t LLDISPLAY_UTILS_allocateDecoderImage(void* data);

#ifdef __cplusplus
	}
#endif
#endif
